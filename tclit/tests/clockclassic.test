# Copyright © 2004 Kevin B. Kenny.  All rights reserved.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

# Copyright © 2024 Nathan Coulter.
# You may distribute and/or modify this program under the terms of the GNU
# Affero General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# See the file "COPYING" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

# clockClassic.test --
#
#   This test file covers the 'clock' command that manipulates time.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands. Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.


namespace eval ::tcl::clockclassic::test {}
apply {{} {

global env
global errorCode

set chan [open [file join [file dirname [
    file normalize [info script]]] clock.test]]
try {
    set clocktestscript [read $chan]
} finally {
    close $chan
}
set status [regexp {\n# START TESTS MARKER\n(.*)\n# END TESTS MARKER\n} \
    $clocktestscript -> clocktestscript]

if {!$status} {
    error [list {could not extract tests from clock.test}]
}

namespace import ::tcl::clock::classic
rename [namespace current]::classic [namespace current]::clock
set clockns [namespace ensemble configure clock -namespace]
set valid_mode 0

if {"::tcltest" ni [namespace children]} {
    package require tcltest 2.5
    namespace import -force ::tcltest::*
}

if {[testConstraint win]} {
    if {[catch {
	    ::tcltest::loadTestedCommands
	    package require registry
	}]} {
	namespace eval $clockns {variable NoRegistry {}}
    }
}

package require msgcat 1.4

testConstraint notclassic 0
testConstraint valid_off 1


testConstraint detroit \
    [expr {![catch {clock format 0 -timezone :America/Detroit -format %z}]}]
testConstraint y2038 \
    [expr {[clock format 2158894800 -format %z -timezone :America/Detroit] eq {-0400}}]


# Note that all code between comments '# BEGIN' and '# END' is
# autogenerated by 'tools/makeTestCases.tcl'.  DO NOT EDIT CODE BETWEEN
# '# BEGIN' and '# END'.

# Define a fictitious locale, 'en_US_roman', for formatting of clock
# strings with localized numerics and eras.  This locale will be used
# in testing the 'clock' command.

namespace eval $clockns {
    ::msgcat::mcmset en_US_roman {
	LOCALE_ERAS {
	    {-62164627200 {} 0}
	    {-59008867200 c 100}
	    {-55853107200 cc 200}
	    {-52697347200 ccc 300}
	    {-49541587200 cd 400}
	    {-46385827200 d 500}
	    {-43230067200 dc 600}
	    {-40074307200 dcc 700}
	    {-36918547200 dccc 800}
	    {-33762787200 cm 900}
	    {-30607027200 m 1000}
	    {-27451267200 mc 1100}
	    {-24295507200 mcc 1200}
	    {-21139747200 mccc 1300}
	    {-17983987200 mcd 1400}
	    {-14828227200 md 1500}
	    {-11672467200 mdc 1600}
	    {-8516707200 mdcc 1700}
	    {-5364662400 mdccc 1800}
	    {-2208988800 mcm 1900}
	    {946684800 mm 2000}
	}
	LOCALE_NUMERALS {
	    ? i ii iii iv v vi vii viii ix
	    x xi xii xiii xiv xv xvi xvii xviii xix
	    xx xxi xxii xxiii xxiv xxv xxvi xxvii xxviii xxix
	    xxx xxxi xxxii xxxiii xxxiv xxxv xxxvi xxxvii xxxviii xxxix
	    xl xli xlii xliii xliv xlv xlvi xlvii xlviii xlix
	    l li lii liii liv lv lvi lvii lviii lix
	    lx lxi lxii lxiii lxiv lxv lxvi lxvii lxviii lxix
	    lxx lxxi lxxii lxxiii lxxiv lxxv lxxvi lxxvii lxxviii lxxix
	    lxxx lxxxi lxxxii lxxxiii lxxxiv lxxxv lxxxvi lxxxvii lxxxviii
	    lxxxix
	    xc xci xcii xciii xciv xcv xcvi xcvii xcviii xcix
	    c
	}
	DATE_FORMAT {%m/%d/%Y}
	TIME_FORMAT {%H:%M:%S}
	DATE_TIME_FORMAT {%x %X}
	LOCALE_DATE_FORMAT {die %Od mensis %Om annoque %EY}
	LOCALE_TIME_FORMAT {%OH h %OM m %OS s}
	LOCALE_DATE_TIME_FORMAT {%Ex %EX}
	BCE {Before Christ}
	CE {Anno Domini}
    }
}

#----------------------------------------------------------------------
#
# The tests for the Windows platform are careful *not* to muck with
# the system registry.  Instead, the 'registry' command is overridden
# in the $clockns namespace.
#
#----------------------------------------------------------------------

namespace eval ::testClock {
    namespace export registry
    set reg \
	[dict create \
	     HKEY_CURRENT_USER\\Control\ Panel\\International \
	     [dict create \
		  locale 0409 \
		  sShortDate dd-MMM-yyyy \
		  sLongDate "'the' dd''' day of' MMMM yyyy" \
		  sTimeFormat "h:mm:ss tt"] \
	     HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation \
	     [dict create \
		  Bias 300 \
		  StandardBias 0 \
		  DaylightBias -60 \
		  StandardStart \x00\x00\x0B\x00\x01\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00 \
		  DaylightStart \x00\x00\x03\x00\x02\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00]]
}


proc ::testClock::registry { cmd path key } {
    variable reg
    if { $cmd ne {get} } {
	return -code error "test case attempts to write/query the registry"
    }
    if { ![dict exists $reg $path $key] } {
	return -code error "test case attempts to read unknown registry entry $path $key"
    }
    return [dict get $reg $path $key]
}

# Test some of the basics of [clock format]

test clock-1.0 "clock format - wrong # args" {
    list [catch {clock format} msg] $msg $::errorCode
} {1 {wrong # args: should be "clock format clockval ?-format string? ?-gmt boolean? ?-locale LOCALE? ?-timezone ZONE?"} {CLOCK wrongNumArgs}}

test clock-1.1 "clock format - bad time" {
    list [catch {clock format foo} msg] $msg
} {1 {expected integer but got "foo"}}

test clock-1.4 "clock format - bad flag" {*}{
    -body {
	list [catch {clock format 0 -oops badflag} msg] $msg $::errorCode
    }
    -match glob
    -result {1 {bad option "-oops": must be -format, -gmt, -locale, or -timezone} {CLOCK badOption -oops}}
}

# Test input conversions.

test clock-6.10 {input of seconds - overflow} {
    list [catch {clock scan 9223372036854775808 -format %s -gmt true} result opt] $result [dict getd $opt -errorcode ""]
} {1 {integer value too large to represent} {CLOCK dateTooLarge}}

test clock-6.10c {input of seconds - overflow ??, bug [1f40aa83c5]} knownBug {
    clock scan 27670116110564327423 -gmt true
} 89170590268800
test clock-6.10d {input of seconds - overflow ??, bug [1f40aa83c5]} knownBug {
  clock scan 27670116110564327424 -gmt true
} -90247104115200


try $clocktestscript


test clock-9.2 {Julian day takes precedence over ccyymmdd} {
    clock scan {2440588 20000101} -format {%J %Y%m%d} -gmt true
} 0

# BEGIN testcases11

# Test precedence among yyyymmdd and yyyyddd

test clock-11.1 {precedence of ccyyddd and ccyymmdd} {
    clock scan 19700101002 -format %Y%m%d%j -gmt 1
} 86400
test clock-11.2 {precedence of ccyyddd and ccyymmdd} {
    clock scan 01197001002 -format %m%Y%d%j -gmt 1
} 86400
test clock-11.3 {precedence of ccyyddd and ccyymmdd} {
    clock scan 01197001002 -format %d%Y%m%j -gmt 1
} 86400
test clock-11.4 {precedence of ccyyddd and ccyymmdd} {
    clock scan 00219700101 -format %j%Y%m%d -gmt 1
} 0
# END testcases11

# Legacy tests

# clock clicks

# clock scan
test clock-34.1 {clock scan tests} {
    list [catch {clock scan} msg] $msg
} {1 {wrong # args: should be "clock scan string ?-base seconds? ?-format string? ?-gmt boolean? ?-locale LOCALE? ?-timezone ZONE?"}}

test clock-34.9 {clock scan tests} {
    list [catch {clock scan "Jan 12" -bad arg} msg] $msg
} {1 {bad option "-bad": must be -base, -format, -gmt, -locale, or -timezone}}
# The following two two tests test the two year date policy
test {clock-34.12 nogmt} {clock scan, relative times} {
    set time [clock scan "Oct 23, 1992 -1 day"]
    clock format $time -format {%b %d, %Y}
} "Oct 22, 1992"
test {clock-34.13 nogmt} {clock scan, ISO 8601 base date format} {
    set time [clock scan "19921023"]
    clock format $time -format {%b %d, %Y}
} "Oct 23, 1992"
test {clock-34.14 nogmt} {clock scan, ISO 8601 expanded date format} {
    set time [clock scan "1992-10-23"]
    clock format $time -format {%b %d, %Y}
} "Oct 23, 1992"
test {clock-34.15 nogmt} {clock scan, DD-Mon-YYYY format} {
    set time [clock scan "23-Oct-1992"]
    clock format $time -format {%b %d, %Y}
} "Oct 23, 1992"
test {clock-34.16 nogmt} {clock scan, ISO 8601 point in time format} {
    set time [clock scan "19921023T235959"]
    clock format $time -format {%b %d, %Y %H:%M:%S}
} "Oct 23, 1992 23:59:59"
test {clock-34.17 nogmt} {clock scan, ISO 8601 point in time format} {
    set time [clock scan "19921023 235959"]
    clock format $time -format {%b %d, %Y %H:%M:%S}
} "Oct 23, 1992 23:59:59"
test {clock-34.18 nogmt} {clock scan, ISO 8601 point in time format} {
    set time [clock scan "19921023T000000"]
    clock format $time -format {%b %d, %Y %H:%M:%S}
} "Oct 23, 1992 00:00:00"

# CLOCK SCAN REAL TESTS
# We use 5am PST, 31-12-1999 as the base for these scans because irrespective
# of your local timezone it should always give us times on December 31, 1999
set 5amPST 946645200
test clock-34.19 {clock scan, number meridian} {
    set t1 [clock scan "5 am" -base $5amPST -gmt true]
    set t2 [clock scan "5 pm" -base $5amPST -gmt true]
    set t3 [clock scan "5 a.m." -base $5amPST -gmt true]
    set t4 [clock scan "5 p.m." -base $5amPST -gmt true]
    list \
	    [clock format $t1 -format {%b %d, %Y %H:%M:%S} -gmt true] \
	    [clock format $t2 -format {%b %d, %Y %H:%M:%S} -gmt true] \
	    [clock format $t3 -format {%b %d, %Y %H:%M:%S} -gmt true] \
	    [clock format $t4 -format {%b %d, %Y %H:%M:%S} -gmt true]
} [list "Dec 31, 1999 05:00:00" "Dec 31, 1999 17:00:00" \
	"Dec 31, 1999 05:00:00" "Dec 31, 1999 17:00:00"]
test clock-34.20 {clock scan, number:number meridian} {
    clock format [clock scan "5:30 pm" -base $5amPST -gmt true] \
	    -format {%b %d, %Y %H:%M:%S} -gmt true
} "Dec 31, 1999 17:30:00"

# weekday specification and base.

# clock seconds
test clock-37.1 {%s gmt testing} {
    set s [clock seconds]
    set a [clock format $s -format %s -gmt 0]
    set b [clock format $s -format %s -gmt 1]
    # %s, being the difference between local and Greenwich, does not
    # depend on the time zone.
    set c [expr {$b-$a}]
} {0}

test clock-45.1 {regression test - time zone containing only two digits} \
    -body {
	clock scan 1985-04-12T10:15:30+04 -format %Y-%m-%dT%H:%M:%S%Z
    } \
    -result 482134530

# case-insensitive matching of weekday and month names [Bug 1781282]

test clock-61.1 {overflow of a wide integer on output} {*}{
    -body {
	clock format 0x8000000000000000 -format %s -gmt true
    }
    -result {integer value too large to represent}
    -returnCodes error
}
test clock-61.2 {overflow of a wide integer on output} {*}{
    -body {
	clock format -0x8000000000000001 -format %s -gmt true
    }
    -result {integer value too large to represent}
    -returnCodes error
}
test clock-61.3 {near-miss overflow of a wide integer on output} {
    clock format 0x7fffffffffffffff -format %s -gmt true
} [expr {0x7fffffffffffffff}]
test clock-61.4 {near-miss overflow of a wide integer on output} {
    clock format -0x8000000000000000 -format %s -gmt true
} [expr {-0x8000000000000000}]

# cleanup

namespace delete ::testClock
${clockns}::ClearCaches
::tcltest::cleanupTests
return





#apply
} ::tcl::clockclassic::test}


# Local Variables:
# mode: tcl
# End:
